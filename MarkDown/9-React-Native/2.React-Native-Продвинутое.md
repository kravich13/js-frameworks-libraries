# Продвинутый React Native

- [Продвинутый React Native](#продвинутый-react-native)
  - [Навигация](#навигация)
    - [Установка](#установка)
    - [Запуск](#запуск)
    - [Атрибут options у Stack.Screen](#атрибут-options-у-stackscreen)
    - [Переход на другую страницу](#переход-на-другую-страницу)
    - [Передача данных между страницами](#передача-данных-между-страницами)
  - [Работа с формами](#работа-с-формами)
    - [Работа с формой](#работа-с-формой)

## Навигация 

### Установка 

```bash
npm i react-navigation @react-navigation/native @react-navigation/stack
expo install react-native-screens react-native-safe-area-context
```

### Запуск

Для запуска и работоспособности пишем следующее:

```jsx
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import React from 'react';
import { Contacts } from '../pages/Contacts';
import { Main } from '../pages/Main';

const Stack = createStackNavigator();

export const Navbar = () => {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="Main" component={Main} options={{ title: 'Main' }} />
        <Stack.Screen name="Contacts" component={Contacts} options={{ title: 'All title' }} />
      </Stack.Navigator>
    </NavigationContainer>
  );
};
```

Логика здесь примерно такая же, как и в обычном React. 

Отличия свойства `title` на Android и iOS в том, что на IOS есть дефолтное выравнивание окна по центру. Это нужно учитывать.

**Важно**: чтобы все компоненты внутри атрибута `component` показывались - нужно в самом главном компоненте `App` в главном `View` оставить свойство `flex: 1`, иначе на экране будет пусто. 


### Атрибут options у Stack.Screen

Этот атрибут принимает в себя объектов параметров, коих очень много. Самые базовые из них - установка navbar (хедер) и его стилизация.

По дефолту на Android navbar выглядит так: 

![](./img/photo_2022-01-05_10-32-54.jpg)

На iOS заголовок находится в центре экрана. 

Для стилизации этого хедера - можно указывать следующее:

```jsx
<Stack.Screen
  name="Main"
  component={Main}
  options={{
    // если не указать title - хедер будет взят из name (Main)
    title: 'Main',

    // стилизация контейнера хедера
    headerStyle: { backgroundColor: '#eb5d3d', height: 100 },

    // стилизация title
     headerTitleStyle: {
        alignSelf: 'center',
        borderWidth: 1,
        borderColor: 'black',
        borderStyle: 'solid',
        borderRadius: 13,
        paddingHorizontal: 13,
        fontSize: 20,
      },

    // выровнять элемент по центру (for Android)
    headerTitleAlign: 'center',

    // изменить цвет title и кнопки назад
    headerTintColor: 'black', 
  }}
/>
```


### Переход на другую страницу

Для того, чтобы перейти на другую страницу по клику - достаточно сделать следующее:

```jsx
import React, { useState } from 'react';
import { Button, StyleSheet, View } from 'react-native';

export const Main = ({ navigation }) => {
  const loadScene = () => {
    navigation.navigate('Contacts');
  };

  return (
    <View style={styles.container}>
      <Button title="Open page Contacts" color="green" onPress={loadScene} />
    </View>
  );
};
```

Пропс `navigation` передаётся автоматически сквозь компонент `Stack.Screen`, поэтому передавать его не нужно. 

Для перенаправления на другую страницу - вызываем `navigation.navigate('Contacts')` с тем именем компонента, который указан как `name="Contacts"` в `Stack.Screen `. 

Если нужно **вернуться** на страницу назад без указания главного/предыдущего компонента - просто указываем `navigation.back()`. 

### Передача данных между страницами

Для передачи данных между страницами можно передавать параметры как: `navigation.navigate(name, {})`:


```jsx
export const ListCoins = ({ navigation }) => {
  const [list] = useState([
    { id: '1', ticker: 'BTC', fullName: 'Bitcoin' },
    { id: '2', ticker: 'ETH', fullName: 'Ethereum' },
    { id: '3', ticker: 'EOS', fullName: 'EOS' },
    { id: '4', ticker: 'NEO', fullName: 'Neo' },
    { id: '5', ticker: 'IOTA', fullName: 'MIOTA' },
  ]);

  return (
    <View style={styles.block}>
      <FlatList
        data={list}
        renderItem={({ item }) => {
          return (
            <TouchableOpacity 
              onPress={() => navigation.navigate('CoinInfo', { item })}
            >
              <Text>{item.ticker}</Text>
            </TouchableOpacity>
          );
        }}
        keyExtractor={(item) => item.id}
      />
    </View>
  );
};
```

Отрисовываем в списке весь стейт и затем с помощью `onPress` вызываем переадресацию на другую страницу с нужными параметрами. В данном случае - этот же самый объект `item`. 


И затем в компоненте можно получить передаваемые параметры пропсом `route`, который представляет из себя такой объект

```js
Object {
  "key": "CoinInfo-ly8A_u_vxGqbKC_IrD9Gg",
  "name": "CoinInfo",
  "params": Object {
    "item": Object {
      "fullName": "MIOTA",
      "id": "5",
      "ticker": "IOTA",
    },
  },
  "path": undefined,
}
```
***

## Работа с формами

Поскольку в React-Native нет компонента `form`, то нет удобной связи между инпутами в нём.

Для решения проблемы есть модуль Formik. Описание: https://formik.org/

Устанавливаем: `npm i formik`

### Работа с формой

Работа с формой выглядит так: 

```jsx
import React from 'react';
import { StyleSheet, TextInput } from 'react-native';
import { gContainerContent } from '../styles';
import { Formik } from 'formik';

export const Form = () => {
  return (
    <View>
      <Formik initialValues={{ ticker: '', fullName: '', src: '' }} onSubmit={onSubmit}>
        {({values, handleChange}) => {
          return <View>
            <TextInput
              value={values.ticker}
              placeholder="Enter the ticker..."
              onChangeText={handleChange('ticker')}
            />
            <TextInput
              value={values.fullName}
              placeholder="Enter the fullname..."
              onChangeText={handleChange('fullName')}
            />
            <TextInput
              value={values.src}
              placeholder="Enter the link for photo..."
              onChangeText={handleChange('src')}
            />

            <View>
              <Button title="Добавить" onPress={handleSubmit} />
            </View>

          </View>;
        }}
      </Formik>
    </View>
  );
};
```

Особенности: 
* внутренний компонент внутри формы с пропсами
* атрибут `initialValue` - своего рода аналог `useState` для каждого инпута формы
* можно писать теги как `input` и `button` вместо компонентов RN
* есть методы для валидации (middleware)
* есть возможность использовать как хук `useFormik`


Чтобы изменить `initialState` - нужно достать пропс `handleChange` и передать в него тот ключ, который ему принадлежит в виде строки.

С помощью пропса `handleSubmit` можно отправить событие на срабатывание `onSubmit` в Formik.

Работа с отправкой формы выглядит так:

```js
const onSubmit = (data, action) => {
  const { fullName, ticker, src } = data;

  if (fullName.trim() || ticker.trim() || src.trim()) {
    addCoin(data);
    action.resetForm();
  } else {
    Alert.alert('An input is empty');
  }
};
```

Есть второй параметр `action` из `onSubmit` Formik, который имеет методы. Например `.resetForm()` позволяет очистить все поля сразу. 