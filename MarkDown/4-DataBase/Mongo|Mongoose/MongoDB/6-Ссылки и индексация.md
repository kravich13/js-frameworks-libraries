# Ссылки и работа с индексами

## Установка ссылок в БД

### ***Ручная установка ссылок:***

Ручная установка ссылок сводится к присвоению значения поля `_id` **одного** документа полю **другого** документа.

Есть две коллекции: `link1` с компанией и `link2` с работником этой компании:

```javascript
// Коллекция1, у которой идентификатор - Microsoft
db.link1.save({"_id": "microsoft", year: 1974})


// Коллекция2, у которой работник Vlad из компании Microsoft
db.link2.save({name: "Vlad", age: 28, company: "microsoft"})


// Получение документа из Коллекции2
user = db.link2.findOne()

// В данном случае имеется ввиду, что выше добавленный элемент будет единственным в коллекции

db.link1.findOne({_id: user.company})
// { "_id" : "microsoft", "year" : 1974 }
// User Vlad работает в компании Microsoft
```

### ***Автоматическое связывание:***

Автоматическое связывание производится с помощью метода `DBRefs`, в котором есть три поля:

* `$ref` - указывает на коллекцию ссылочного документа.
* `$id` - указывает поле `_id` ссылочного документа.
* `$db`- необязательное поле, содержит имя БД, в которой находится ссылочный документ.


```json
{
   "_id" : ObjectId("5126bbf64aed4daf9e2ab771"),
   "address": {
        "$ref": "Грицевца",
        "$id": ObjectId("5126bc054aed4daf9e2ab772"),
        "$db": "userMessages"
    },
   "contact": "0665903793",
   "name": "Vlad Kravich"
}

var user = db.usersTest.findOne({"name": "Vlad Kravich"})
var dbRef = user.address

db[dbRef.$ref].findOne({ "_id": (dbRef.$id) })
```
***


## Индексация полей

Есть коллекция на 13000 документов, в одном документе лежит поле Кравич. Для того, чтобы найти этого Кравича - нужно пройтись по **всей** коллекции по **каждому** документу, пока поиск до него не дойдёт. А ведь Кравич может быть и на 13000 позиции в худшем случае.

Для облегчения поиска существуют индексы (как сортировка в `sql` и её подзапрос). 

### ***Создание индексов:***

Для установки полю индекса применяется метод `createIndex()`.

```javascript
db.users2.createIndex({ name: 1 })  // от A - Z
db.users2.createIndex({ name: -1 }) // от Z до A
```

* Значение `1` упорядочивает элементы в порядке **возрастания**.
* Значение `-1` упорядочивает элементы в порядке **убывания**.

### ***Составные индексы:***

Составные индексы - это одна структура индекса, которая содержит ссылки на несколько полей.

Если составной индекс состоит из `{ age: 1, salary: -1}`, то индекс сортируется сначала по `age` и затем в пределах `age` по `salary`:

```javascript
// Самый ранний возраст к самой высокой зарплате по этому возрасту
db.agetopay.createIndex({ age: 1, salary: -1 })


> db.agetopay.find({ age: 24})      // 1)
// {"age" : 24, "salary" : 600 }
// {"age" : 24, "salary" : 400 }

> db.agetopay.find({ age: 26})      // 1)
// {"age" : 26, "salary" : 2000 }
// {"age" : 26, "salary" : 300 }

> db.agetopay.find({ salary: 300})  // 2)
// { {"age" : 23, "salary" : 300 }
// { {"age" : 26, "salary" : 300 }
// { {"age" : 22, "salary" : 300 }
```

Разбор ситуации: 
1. поиск просходит по значению `age`, но сортировка внутри этого поля производится в порядке **убывания** по полю `salary`. 
2. если сделать поиск по значению `salary` - то сортировка `age` не будет идти по **возрастанию**, т.к. `salary` не содержит ссылку на `age`.


### ***Мультиклавишные индексы:***

`MultiKey` индекс задаёт ключ для каждого элемента массива и для каждого элемента массива объектов:

```javascript
// Только работает не знаю как, разберусь
db.users.createIndex({ languages: 1 })
db.users.createIndex({ currency.dollar: 1 })
```

### ***Свойства индексов:***

* ### `uniqe`
    Позволяет установить уникальный `key` для этого поля:

    ```javascript
    // В коллекции будет лишь уникальное поле country
    db.countriesAndCities.createIndex({"country" : 1}, {"unique" : true})
    ```

    При попытке добавить существующее поле выдаст ошибку: `E11000 duplicate key error index:`

* ### `TTL Indexes`
    Спец. индексы, которые используются для автомат. удаления документов из коллекции через определенное время с помощью `{ expireAfterSeconds: numb }`:

    ```javascript
    db.log_events.createIndex( { "expireAt": 1 }, { expireAfterSeconds: 0 } )

    db.log_events.insertOne( {
        "expireAt": new Date('November 30, 2020 13:28:30'),
        "logEvent": 2,
        "logMessage": "Success!"
    })

    // В заданное в expireAt время удалится этот документ
    db.log_events.find() // пусто
    ```

    Промежуток времени устанавливается в секундах. Когда `new Date('November 30, 2020 13:28:30')` наступит, то через `0` секунд удалится документ. 

    В обычном случае в поле типа `Date` пишется дата добавления, а в `expireAfterSeconds: number` указывается промежуток времени, через который документ должен удалиться.

    * Индексируемое поле должно иметь **тип даты `BSON`** или **массив дат `BSON`**.
    * Если индексируемое поле в документе не является **датой** или **массивом**, содержащим значение **даты**, срок действия документа **не** истечет.
    * Если документ **не** содержит проиндексированного поля, срок его действия **не** истечет.

### ***Управление индексами:***

Информация об индексах отдельной коллекции:

```javascript
db.users2.getIndexes()

[
        {
                "v" : 2,
                "key" : {
                        "_id" : 1
                },
                "name" : "_id_"
        },
        {
                "v" : 2,
                "key" : {
                        "name" : 1
                },
                "name" : "name_1"
        },
        {
                "v" : 2,
                "key" : {
                        "age" : 1
                },
                "name" : "age_1",
                "expireAfterSeconds" : 10
        }
]
```

Здесь определено три индекса: `_id`, `name` и `age_1`:
* `key` - используется для поиска максимального и минимального значений, для различных операций, где надо применять данный индекс.
* `name` - применяется в качестве идентификатора для операций администрирования и для **удаления индекса**:

    ```javascript
    db.users2.dropIndex("age_1")
    // индекс удалён
    ```

Также можно удалить **все** индексы сразу:

```javascript
db.users2.dropIndexes()
```