# Выборка (Part 2) и агрегирование

## Выборка данных (Part 2) 

### ***Параметр $natural:***

Если нужно отсортировать **ограниченную** коллекцию, то можно использовать параметр `$natural`. Он позволяет задать сортировку: документы передаются в том порядке, в каком они были добавлены в коллекцию, либо в обратном порядке.

К примеру отбор последних трёх документов:

```json
db.vlad.find().sort({ $natural: -1 }).limit(3)
```

### ***Оператор $slice:***

`$slice` может работать с массивами. Принимает два параметра:

1. Указывает на общеее кол-во возвращаемых документов.
2. Необязательный и если используется, то: 
    * **первый** параметр указывает на **смещение** относительно начала (как `skip`)
    * **второй** - на **ограничение** кол-во извлекаемых документов.

К примеру есть массив `languages` и при выходе нужно сделать так, чтобы в выборку попадал лишь один из языков массива, а не весь массив:

```json
db.users.find({name: "Vlad"}, { languages: {$slice : 1 }})

{ 
    "_id" : ObjectId("5fbf663b661c5d7344e2fcc3"), 
    "name" : "Max", "
    languages" : [ "english" ] 
}
```

Если нужно оставить **один** в массиве **последний**, а не первый документ:

```json
db.users.find ({ name: "Max" }, { languages: {$slice : -1 }})
```

Применение двух параметров, начать выборку с конца с указанным кол-вом элементов:

```json
db.users.find ({ name: "Vlad" }, { languages: {$slice : [-1, 1]}})
```

### ***Курсоры:***

Результат выборки получаемый с помощью `find()` называется курсором:

```javascript
const cursor = db.users.find(); null
// можно добавить null после точки с запятой и тем самым данные не будут выводиться сразу же
```

Курсоры работают как переменные или как подзапросы в SQL. Сохранил и используешь эти данные дальше. 

Курсор обладает методом `hasNext()`, который при переборе показывает,имеется ли ещё в наборе документ. А метод `next` извлекает текущий документ и перемещает курсор к следующему документу в наборе. В итоге в переменной `obj` оказывается документ, к полям которого можно получить доступ:

```javascript
const cursor = db.users.find()
cursor.forEach(function (obj) {
    print(obj.name)
    // Vlad
    // Vlad
    // Max
})
```

Для ограничения выборки используется `limit()`:

```javascript
const cursor = db.users.find()
cursor.limit(2)
cursor.forEach(function (obj) {
    print(obj.name)
})
```

Точно также используются все остальные методы: **метод** к присвоенному подзапросу (переменной) и точно также **можно** все методы использовать по **цепочке**.
***

## Команды группировки

### ***Число элементов в коллекции:***

`count()` показывает кол-во элементов в коллекции:

```javascript
db.users.count() // 3
```

Можно делать группировку, к примеру, сколько элементов в конкретной выборке:

```javascript
db.users.find({ name: "Max" }).count() // 1
```

Также можно сделать цепочку функций для конкретизации условия подсчёта с помощью параметра `true` (конкретно для **цепочки**):

```javascript
db.users.find({ name: "Vlad" }).skip(2).count(true)
```

### ***Функция distinct():***

Применяется для вывода только уникальных полей, как `map`:

```javascript
// В Коллекции 2 Влада, а показывается лишь первый
db.users.distinct("name")
[ "Max", "Vlad" ]
```
***

## Агрегирование 
### ***aggregate():***

Метод `aggregate(pipeline, options)` - это агрегирование: т.е. получение определенных данных при каком-то условии.

Принимает два параметра: 

1. `pipeline` - **массив**, в котором идёт последовательность агрегирования данных (методов).
2. `options` - **документ**, доп. параметры (*офф. докум.*). Только если `pipeline` будет массивом. 

Каждый метод внутри `eggregate()` нужно писать через `$`.


* ### `$group`
    
    Синтаксис:

    ```javascript
    _id :  <выражение> ,  // Группировать по выражению 
    <поле1>:  {  <аккумулятор1>  :  <выражение1>  }, 
    ... 
    ```

    Операторы аккумулятора **возвращают**:

    * `$accumulator` - результат функции аккумулятора.
    * `$addToSet` - массив **уникальных** значений выражений для каждой группы.
    * `$avg` - среднее числовых значений.
    * `$first` - значение из первого документа для каждой группы. Порядок определяется только в том случае, если документы расположены в определенном порядке. 
    * `$last` - значение из последнего документа для каждой группы. порядок определяется только в том случае, если документы расположены в определенном порядке. 
    * `$max` - максимальное значение выражения для каждой группы.
    * `$mergeObjects` -	документ, созданный путем объединения входных документов для каждой группы.
    * `$min` -	наименьшее значение выражения для каждой группы.
    * `$push` -	массив значений выражений для каждой группы.
    * `$stdDevPop` - стандартное отклонение генеральной совокупности входных значений.
    * `$stdDevSamp` - образец стандартного отклонения входных значений.
    * `$sum` - сумму числовых значений. Игнорирует нечисловые значения. 

    
    Для примера найдем уникальные поля `name` и узнаем сколько одинаковых полей в общем:

    ```javascript
    db.users.aggregate([{
        $group: { 
            // Новое поле _id: группировать по выражению `$name`
            // Новое поле total: группировать по аккумулятору $sum
            _id: "$name", total: {$sum: 1} 
        }
        // $martch
        // $sort
        // и т.д.
    }])

    { "_id" : "Anna", "total" : 1 }
    { "_id" : "Max", "total" : 2 }
    { "_id" : "Vlad", "total" : 2 }
    ```

* ### `$match`
    Осуществляет фильтрацию по условию (используется вместо `find()`).

    ```javascript
    db.users.aggregate([
        { $match : { name : "Vlad" } } 
    ])

    // выведет два документа где есть Vlad
    ```
