# Связи таблиц: один ко многим, один к одному, многие ко многим.

## Один ко многим

Для создания связи одна таблица ко многим применяется метод `hasMany()`:

```javascript
const Product = sequelize.define("Product", {
    Id: {
        type: Sequelize.INTEGER,
        autoIncrement: true,
        primaryKey: true,
        allowNull: false
    },
    Name: {
        type: Sequelize.STRING,
        allowNull: false
    },
    Price: {
        type: Sequelize.INTEGER,
        allowNull: false
    }
})


const Company = sequelize.define("Company", {
    Id: {
        type: Sequelize.INTEGER,
        autoIncrement: true,
        primaryKey: true,
        allowNull: false
    },
    Name: {
        type: Sequelize.STRING,
        allowNull: false
    }
})
Company.hasMany(Product) // связывает таблицу Company с таблицей Product
```

По дефолту в зависимой таблице (**Products**) создаётся дополнительный столбец, который имеет название как у имени главной модели (**Company**) и добавляет слоган `id`, т.е. столбец в данном случае называется `CompanyId`. Через этот столбец строка из `Companyies` сможет ссылаться на объект из таблицы `Products`.

Параметр `onDelete` позволяет задать действия при удалении:

```javascript
Company.hasMany(Product, { onDelete: "cascade" })
```

### ***Основные операции:***

Указание ссылки на главную модель, где модель товара соответствует его производителю :

```javascript
Company.create( { Name: "Apple"}).then(res => {

    // получение Id созданной компании
    const compId = res.Id

    // создание пары товаров для этой компании
    Product.create({Name: "iPhone 10", Price: 1000, CompanyId: compId})
    .catch(err => console.log(err))
    Product.create({Name: "iPhone 8 Plus", Price: 500, CompanyId: compId})
    .catch(err => console.log(err))

}).catch(err => console.log(err))
```

```sql
SELECT * FROM Products;
+----+---------------+-------+-----------+
| Id | Name          | Price | CompanyId |
+----+---------------+-------+-----------+
|  1 | iPhone 10     |  1000 |      1    |
|  2 | iPhone 8 Plus |   500 |      1    |
+----+---------------+-------+-----------+

SELECT * FROM Companies;
+----+-------+
| Id | Name  |
+----+-------+
|  1 | Apple |
+----+-------+
```

Второй способ добавления - через главную модель:

```javascript
// Поиск компании с id 1
Company.findByPk(1).then(company => {
    if (!company) return console.log("Company not found.")

    company.createProduct({name:"iPhone 7 Plus", price: 400})
    .catch(err => console.log(err))

}).catch(err => console.log(err))
```
***

## Один к одному

Отношение один к одному указывает, что у таблицы может быть связная таблица в единственным экземпляре.

Для такого подхода применяется метод `hasOne()`. Для примера создание двух таблиц, первая - тренер, вторая - его команда:

```javascript
const Leader = sequelize.define("Leader", {
  Id: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true,
    allowNull: false
  },
  Name: {
    type: Sequelize.STRING,
    allowNull: false
  }
})


const Subordinate = sequelize.define("Subordinate", {
  Id: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    primaryKey: true,
    allowNull: false
  },
  Name: {
    type: Sequelize.STRING,
    allowNull: false
  }
})
```

По дефолту создаётся столбец `LeaderId`, через который идёт связь с таблицей `Leaders`.

### ***Добавление и получение связанных данных:***

Для установки связанных данных применяется метод `setНазвание_Модели()`, к примеру добавим тренера в команду:

```javascript
Coach.create({ name: "Vlad Kravich"})

```