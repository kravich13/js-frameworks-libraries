
# Дженерик типы

- [Дженерик типы](#дженерик-типы)
  - [Суть использования](#суть-использования)
  - [Продвинутые использование](#продвинутые-использование)
    - [Описание интерфейсов](#описание-интерфейсов)
  - [Тестовый пример](#тестовый-пример)


## Суть использования

Дженерик типы позволяют писать динамически входящие типы, которые позволяют избавиться от массивных описаний типов: 

К примеру есть функция, в которой нужно возвращать или число или строку: 

```ts
const testFn = (value: string | number): Number | String => {
  return value
}
testFn(13) // 13 => number
testFn('kravich') // kravich => string
```

С помощью дженерика можно упростить вот так: 

```ts
function testFn<T> (value: T): T {
  return value
}
testFn<Number>(13) // 13 => number
testFn<String>('kravich') // kravich => string
```

Пример с двумя параметрами: 

```ts
function testFn<T, U>(value: T, message: U, what: U): T {
  return value;
}
testFn<Number, String>(13, 'kravich', 'test');
```
***

## Продвинутые использование 

### Описание интерфейсов

Нужно обязательно указывать тип дженерика по умолчанию, чтобы не было ошибки: 

```ts
interface Obj<T = string> {
  a: T
  b: T
}

const obj: Obj = {
  a: 'test',
  b: 'kravich'
}
```
***

## Тестовый пример

Есть класс `Car`, являющийся основой для класссов `Truch` и `Vespa`:

```ts
class Car {
  label: string = 'Generic Car'
  numWheels: Number = 4
  horn() {
    return 'qq all!'
  }
}

class Truck extends Car {
  label = 'Truck'
  numWheels = 24
}

class Vespa extends Car {
  label = 'Vespa'
  numWheels = 2
}

// Входящий тип класса будет наследован от класса Car
function washCar <T extends Car> (car: T): T {
  console.log(`Received a ${car.label} in the car wash.`)
  console.log(`Cleaning all ${car.numWheels} tires.`)
  console.log('Beeping horn -', car.horn())
  console.log('Returning your car now')
  return car
}

const myVespa = new Vespa()
washCar<Vespa>(myVespa)

const myTruck = new Truck()
washCar<Truck>(myTruck)
```

